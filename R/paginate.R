#' Add pagination to a Megamation API request
#'
#' `mm_req_paginate()` adds pagination to a request based on the next_url given
#' by the parsed response.
#'
#' @param req An API request generated by [mm_req()].
#' @returns An object of class `httr2_request`.
#' @export
#' @examplesIf httr2::secret_has_key("HTTR2_KEY")
#' mm_req("workorder") |> mm_req_paginate()
mm_req_paginate <- function(req) {
  check_request(req)

  req |>
    httr2::req_paginate_next_url(
      parse_resp = function(resp) {
        parsed <- resp |> mm_resp_parse()

        url <- parsed$next_page
        url <- if (is.null(url) || url == "") NULL else (url)

        list(data = list(resp), next_url = url)
      },
      n_pages = function(parsed) {
        sub(".*_", "", parsed$page_count) |> as.numeric()
      }
    )
}

#' Bind multiple Megamation API pages by row before converting to a tibble
#'
#' `mm_bind_then_tbl()` is needed as pages can have same-named fields with
#' different types. This is because some field(s) of a given page
#' may or may not contain vectors  of values in one of its row.
#' `mm_bind_then_tbl()` takes care of this possibility by treating each page
#' as a matrix before binding and unnesting their combination.
#'
#' @param pages List of data frames representing Megamation API pages.
#' @returns A data frame of class [`tbl_df`][tibble::tbl_df-class]
#' representing the bound pages.
#' @export
#' @examples
#' # Let each mpg value be equal to a list of itself.
#' # Let each cyl value be equal to the entire vector mtcars$cyl.
#' mtcars_list_cols <- mtcars |>
#'   dplyr::mutate(
#'     mpg = as.list(mpg),
#'     cyl = list(cyl)
#'     )
#' dfs <- list(mtcars, mtcars_list_cols)
#' # Then mm_bind_then_tbl() will unnest mpg but will not unnest cyl.
#' mm_bind_then_tbl(dfs)
mm_bind_then_tbl <- function(pages) {
  matrices <- purrr::map(pages, \(x) as.matrix(x))
  m <- purrr::reduce(matrices, rbind)
  data <- m |> tibble::as_tibble()

  cols <- names(data)
  lengths <- purrr::map_dbl(
    cols,
    \(x) purrr::map_dbl(data[[x]], length) |> max()
  )
  unlisted <- cols[lengths %in% 0:1]

  data |> tidyr::unnest(!!unlisted)
}

#' Detect whether a request is paginated
#'
#' `is_paginated()` checks whether an `httr2_request` has a paginate policy.
#'
#' @inheritParams mm_req_paginate
#' @returns `TRUE` or `FALSE`.
#' @export
#' @keywords internal
#' @examplesIf httr2::secret_has_key("HTTR2_KEY")
#' mm_req("workorder") |> is_paginated()
#' mm_req("workorder") |> mm_req_paginate() |> is_paginated()
is_paginated <- function(req) {
  check_request(req)
 "paginate" %in% names(req$policies)
}

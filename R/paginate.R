#' Add pagination to a Megamation API request
#'
#' `mm_req_paginate()` adds pagination to a request based on the next_url given
#' by the parsed response.
#'
#' @param req An API request generated by [mm_request()].
#' @returns An object of class `httr2_request`.
#' @export
mm_req_paginate <- function(req) {
  check_request(req)

  req |>
    httr2::req_paginate_next_url(
      parse_resp = function(resp) {
        parsed <- resp |> mm_resp_parse()

        url <- parsed$next_page
        url <- if (is.null(url) || url == "") NULL else (url)

        list(data = list(resp), next_url = url)
      },
      n_pages = function(parsed) {
        sub(".*_", "", parsed$page_count) |> as.numeric()
      }
    )
}

#' Bind multiple Megamation API pages by row before converting to a tibble
#'
#' `mm_bind_then_tbl()` is needed as pages can have same-named fields with
#' different types. This is because some field(s) of a given page
#' may or may not contain vectors  of values in one of its row.
#' `mm_bind_then_tbl()` takes care of this possibility by treating each page
#' as a matrix before binding and unnesting their combination.
#'
#' @param pages List of data frames representing Megamation API pages.
#' @returns A data frame of class [`tbl_df`][tibble::tbl_df-class]
#' representing the bound pages.
#' @export
mm_bind_then_tbl <- function(pages) {
  matrices <- purrr::map(pages, \(x) as.matrix(x))
  m <- purrr::reduce(matrices, rbind)
  data <- m |> tibble::as_tibble()

  cols <- names(data)
  lengths <- purrr::map_dbl(
    cols,
    \(x) purrr::map_dbl(data[[x]], length) |> max()
  )
  unlisted <- cols[lengths %in% 0:1]

  data |> tidyr::unnest(!!unlisted)
}

## Or, if using req_paginate_custom()
# matrices <- purrr::map(pages, \(x) pluck(x, "_embedded", "WorkOrder") |> as.matrix())


# Custom Method -----------------------------------------------------------

#' Add pagination to a Megamation API request
#' @inheritParams mm_req_paginate
#' @returns An object of class `httr2_request`.
mm_req_paginate_custom <- function(req) {
  check_request(req)

  req |>
    httr2::req_paginate(
      next_request = function(req, parsed) {
        if (parsed$next_page == "") return(NULL)
        req |> httr2::req_url(parsed$next_page)
      }
    )
}

#' null-default operator
#' @noRd
`%||%` <- rlang::`%||%`

#' Perform a paginated request
#' @param req An API request generated by [mm_request()] with pagination from
#' [mm_req_paginate()].
#' @param max_pages Max number of pages to request.
#' @returns A list of data frames representing the pages of responses.
mm_req_perform_paginate_custom <- function(req, max_pages = NULL) {
  check_request(req)

  out <- vector("list", max_pages %||% 10)
  i <- 1L

  repeat({
    out[[i]] <- httr2::req_perform(req) |> mm_resp_parse()
    if (!is.null(max_pages) && i == max_pages) {
      break
    }

    req <- req |> httr2::iterate_next_request(parsed = out[[i]])

    if (is.null(req)) {
      break
    }

    i <- i + 1L
    if (i > length(out)) {
      length(out) <- length(out) * 2L
    }
  })

  if (i != length(out)) {
    out <- out[seq_len(i)]
  }
  out

}

#' Detect whether a request is paginated
#'
#' `is_paginated()` checks whether an `httr2_request` has a paginate policy.
#'
#' @param req An API request.
#' @returns `TRUE` or `FALSE`.
#' @export
is_paginated <- function(req) {
  check_request(req)
 "paginate" %in% names(req$policies)
}
